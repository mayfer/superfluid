<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Moire</title>

        <script type="text/javascript" src="GlslCanvas.js"></script>

        <style>
            body {
                background: #101515;
            }

            #glslCanvas {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
            }

        </style>

    </head>
    <body>
        <canvas id="glslCanvas" data-gl_Fragment="


#define TWO_PI 6.28318530718

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

const vec2 u_mouse = vec2(500., 500.);

//I didn't make this. Credit to:
//https://gist.github.com/yiwenl/745bfea7f04c456e0101
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

//I didn't make this either. Credit to:
//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


const int pointCount = 32;
    
#define PI 3.1415926535897932384626433832795
    
vec2 magneticField(vec3[pointCount] pts, vec2 position) {
    vec2 netForce = vec2(0, 0);
    for(int i = 0; pointCount > i; i++) {
    	netForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;
    }
    return netForce;
}

float modsign(float a, float b) {
	return mod(a, b) * sign(a);
}

vec3 points[pointCount];


void main( )
{
    
    vec2 m = vec2(u_mouse.x / u_resolution.x, u_mouse.y / u_resolution.y);
    
    for(int i = 0; pointCount > i; i++) {
        int pc = pointCount;
    	points[i] = vec3(0.0);
        points[i].x = rand(vec2(i, i + pc)) + sin(u_time * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;
        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(u_time * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;
        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;
    }
    
    points[1].x = m.x;
    points[1].y = m.y;
    points[1].z = -1.0;
    
    //points[0] = vec3(0.25, 0.25, 1.0);
    
    //points[2] = vec3(0.75, 0.75, 1.0);
	//points[1] = vec3(m.x, m.y, -1.0);
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_FragCoord/u_resolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(u_time+uv.xyx+vec3(0,2,4));

    // Output to screen
    //gl_FragColor = vec4(col,1.0);
    
    vec2 mField = magneticField(points, uv);
    float fieldMag = distance(vec2(0, 0), mField);
    float fieldDir = atan(mField.y, mField.x);
    //gl_FragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);
    vec2 mDeriv = mField - magneticField(points, uv + vec2(0.0001));
    
    //gl_FragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);
    float logmag = log(fieldMag);
    //float threshold = (1.0 / (1.0 + pow(3.0, -logmag)));
    float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);//pow((pow(2.0, 0.333) / (1.0 + pow(2.0, -distance(vec2(0.0), mDeriv)))), 3.0);
    //vec3 col = vec3((mod(logmag * 4.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0);
    float col = (mod(fieldDir / PI * 24.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0;
    gl_FragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);
}



" width="800" height="600"></canvas>
    </body>

    <script>
        var canvas = document.getElementById("glslCanvas");
        var sandbox = new GlslCanvas(canvas);
        var texCounter = 0;
        var sandbox_content = "";
        var sandbox_title = "";
        var sandbox_author = "";
        var sandbox_thumbnail = ""; 
        canvas.style.width = '100%';
        canvas.style.height = '100%';

    </script>
</html>
